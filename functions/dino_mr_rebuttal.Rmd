---
title: "Dino Metabolisim Reanalysis"
author: "Chauncey Gadek"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  rmdformats::readthedown:
    highlight: tango
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=F, warning=F, message=F, include=F}
library(ggplot2)
library(ggpubr)
library(tidyr)
library(dplyr)
library(reshape)
library(tibble)
library(purrr)
library(tdr)
library(faux)
library(ggridges)
library(MASS)
library(tidybayes)
library(brms)
library(marginaleffects)
library(ape)
library(caper)
library(geiger)
library(nlme)
library(phytools)
library(robustHD)
library(emmeans)
library(loo)
library("corpcor")
library(caret)
theme_set(theme_classic())
#Load functions
sapply(list.files(pattern="[.]R$", path="~/Dropbox/Research/Dino_metabolics_rebuttal/functions", full.names=TRUE), source)

```

```{r, echo=F, warning=F, message=F}
dat.lm <- read.csv(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/dino_MR_lm_jg.csv", header=T, stringsAsFactors = T)

dat.calib <- read.csv(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/calib.csv", header=T, stringsAsFactors = T)

dat.calib.extant <- read.csv(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/calib_25.csv", header=T, stringsAsFactors = T)

dat.calib.fossil <- read.csv(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/calib_fossil.csv", header=T, stringsAsFactors = T)


#load tree and taxon times from Iris Mendez' GitHub:https://github.com/IrisMenendez/Dinosaur_metabolism/blob/main/Data/Final_tree.nex

tree <- read.nexus(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/consensus_Paleotree_final.tre")

tree.tt <- ape::read.tree(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/extant.nwk")

disc.df <-read.csv(file="~/Dropbox/Research/Dino_metabolics_rebuttal/data/disc_fossil.csv", header=T, stringsAsFactors = T)

```
This markdown file is meant to illustrate workflow (at a high level) for our reanalysis of Weimann _et al._ 2022. Broadly, we correct a single erroneous calibration point and reanalyse the data following their presumed workflow. We then simulate data from re calibrated _MC in vivo_ values and ask about their classification success.


# Apply Prediction Interval to original data

## Linear model of orginal data as in Figure 1d.
```{r, linear model, echo=F}
lm.m.mr <- lm(Log.10..Upper.MR ~ Log.10..Body.Mass..g., data=dat.lm)
summary(lm.m.mr)

```


```{r, CVRSME, echo=F, warning=F, message=F, eval=F}
#my own simple function
cvrmse(lm.m.mr)
#0.13


#function from tdr packge
tdStats(m = lm.m.mr$fitted.values, o=lm.m.mr[["model"]][[1]])
#same cvrsme
0.13

#CRSME is pretty low, but calibration has some issues which we will tackle below. 
```




We first deal with the issue of appropriate predictive tests of the original data and framework. Weimann _et al._ used a 95% confidence interval to "predict" unknown thermal regimes. But confidence intervals are inappropriate for predicting unknown values. Prediction intervals are a more appropriate classification tool--relating directly to a model's ability to predict new data. We generate prediction intervals for known endotherms and known other (thermy) based on the unaltered Weimann _et al._ data. It is important to understand the overlap between prediction intervals parameterized from known data in order to evaluate the predictive power of Weimann _et al.'s_ framework. 
```{R, prediction interval, echo=F, warning=F, message=F}

calib.masses <- dat.lm%>%
  dplyr::select(Taxon, Log.10..Body.Mass..g., Body.mass..g., classification)%>%
  filter(Taxon %in% dat.calib$Taxon)

calib.extant.masses <- dat.lm%>%
  dplyr::select(Taxon, Log.10..Body.Mass..g., Body.mass..g., classification)%>%
  filter(Taxon %in% dat.calib.extant$Taxon.Name)

dat.calib <-left_join(dat.calib, calib.masses)

dat.calib.extant<- dat.calib.extant%>%
  mutate(Taxon = Taxon.Name)%>%
left_join(., calib.extant.masses, by="Taxon")%>%
  mutate(Log10.Lit.Mass.Specific.MR = log10(Literature.MR..mL.O2...1.h...1.g. * Body.mass..g..x))



#model only endotherms
end.mod <- dat.lm%>%
  filter(classification=="endo",
         Age =="Extant")%>%
  lm(Log.10..Upper.MR ~Log.10..Body.Mass..g., data=.)

# model everything but endotherms

oth.mod <- dat.lm%>%
  filter(classification %in% c("ecto", "meso","oth"),
         Age =="Extant")%>%
  lm(Log.10..Upper.MR ~Log.10..Body.Mass..g., data=.)

#Prediction intervals
orig_var_full <- predict(lm.m.mr, interval="prediction")

orig_df_full <- cbind(dat.lm, orig_var_full)

orig_var_endo <- predict(end.mod, interval="prediction")

orig_df_endo <- cbind(dat.lm%>%filter(classification=="endo",
         Age =="Extant"), orig_var_endo)

orig_var_oth <- predict(oth.mod, interval="prediction")

orig_df_oth <- cbind(dat.lm%>%filter(classification %in% c("ecto", "meso","oth"),
         Age =="Extant"), orig_var_oth)

```

## Plot prediction intervals
```{r, fig.dim=c(8,6), echo=F, warning=F, message=F}
#Plot it
#for plot label

ggplot(orig_df_full, aes(Log.10..Body.Mass..g., Log.10..Upper.MR))+
    #geom_point() +
    #geom_line(aes(y=lwr), color = "red", linetype = "dashed")+
    #geom_line(aes(y=upr), color = "red", linetype = "dashed")+
    #geom_smooth(method=lm, se=F, color="black")+
  #geom_smooth(data= orig_df_full %>% filter(thermy=="endo"), method=lm, se=T, fill="goldenrod", linetype=0)+
 # geom_smooth(data=orig_df_endo, method="lm", fill="goldenrod1", linetype=0)+
     geom_line(data=orig_df_endo,aes(y=lwr), color = "goldenrod", linetype = "dashed")+
    geom_line(data=orig_df_endo, aes(y=upr), color = "goldenrod", linetype = "dashed")+
 # geom_smooth(data=orig_df_oth, method="lm", fill="dodgerblue2", linetype=0)+
     geom_line(data=orig_df_oth,aes(y=lwr), color = "dodgerblue2", linetype = "dashed")+
    geom_line(data=orig_df_oth, aes(y=upr), color = "dodgerblue2", linetype = "dashed")+
  geom_point(data= dat.lm, mapping= aes(Log.10..Body.Mass..g., Log.10..Upper.MR, fill=thermy), shape=21)+
  scale_fill_manual(values=c("goldenrod", "dodgerblue2"))+
  labs(y=expression(log["10"](MR)), x= expression(log["10"]~Body~Mass~(g)))+
  theme_classic(base_size = 14)+
  theme(legend.position = c(0.8,0.17))+
  geom_text(data=dat.lm, aes(label=Taxon), size=2.5,
    nudge_x = 0.2, nudge_y = 0.1, 
    check_overlap = T
  )

```

Blue points are non-endotherm samples and yellow points are endotherm samples as designated by Weimann _et al._ 2022. Yellow dashed lines are upper and lower bounds of prediction interval for known endotherm only linear model. Blue dashed lines delineate prediction interval for known other points. Note the prediction interval for known other encompasses 100% of known endotherm points (if extrapolated).

## Expected Scaling relationship

Metabolic rate literature has shown that metabolic rate scales with mass to the power of (-1/4). Therefore log-log plots of MR against mass show a negative slope of ~ -1/4. Is this present in Weimann et al. Literature-derived MR and mass data? Given the poor documentation of sources for literature MR, the disparate types of MR used in this analysis (BMR, FMR, etc...) do their data show this expected trend?

```{r}

ggplot(data=dat.calib.extant%>%filter(classification %in% c("endo","ecto")), aes(Log.10..Body.Mass..g., log10(Literature.MR..mL.O2...1.h...1.g.), color=classification))+
  geom_point()+
  geom_smooth(method="lm", alpha=0.4, se=F)+
  stat_regline_equation()+
  theme_classic()+
  theme(
    legend.position = "none"
  )+
  scale_color_manual(values=c("blue", "red"))+
  labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Literature Mass-Specific MR (ml", O[2]*h^-1*g^-1, ")")))
  

```

# Calibration issues

The value of 11 for Anseriform duck which drives the Weimann et al. 2022 calibration (Figure 1B) is from Legendre 2016 by way of Montes 2007 where they measured RMR in captive _Anas platyrynchos_ ducklings in _mL_ O~2~ * h^-1^ * g^-1^ in Montes and used an allometric correction in Legendre _mL_ O~2~ * h^-1^ * g^-0.67^ for the same values. Weimann et al. use the allometrically corrected duck value with an uncorrected axis and possibly uncorrected values for other taxa inflating the positive relationship between Literature MR and Amide derived values. 

Therefore the value in Figure 1b for the Anseriform duck reads 11 but it should in fact be 2.35 based on calculation from the original source Montes et al. 2007.

Here are two linear models. The first is the model they used for fossil calibration in Weimann _et al._ 2022. The second is the model with a corrected value for the Duck point.

```{r, echo=F}
dat.calib[9,"Taxon"]<- dat.calib[8,1]
dat.calib[9,2]<- dat.calib[8,2]
dat.calib[9,3]<- 2.35

lm.calib <-dat.calib%>%filter(!row_number() %in% c(9))%>%
  lm(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo, data=.)

summary(lm.calib)

#  This is how fossils were calibrated (1.2994*Fossil Amide here)-3.9047
#with added uncertainty add 1.2 to the value calculated above

#Now replace the erroneous point

lm.calib.rm <-dat.calib%>%filter(!row_number() %in% c(8))%>%
  lm(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo, data=.)

summary(lm.calib.rm)

```
We can see that the corrected point brings down the R^2^ value and raises the _P_ value as expected. So the calibration formula for fossils goes from 1.2994 * ( _MC in vivo_) - 3.9047 to 0.3207 * ( _MC in vivo_) + 0.3371.

## Plot R^2^ with/without corrected calibration

Visualize  the calibration according to the supplementary data calibration tab n=8 extant amniotes and calibration with duck removed.

```{r, echo=F, message=F}
ggplot(data=dat.calib%>%filter(!row_number() %in% c(9)), aes(X.S.N..Amide...MC.in.vivo, Literature.MR..mL.O2...1.h...1.g.))+
  geom_point()+
  geom_smooth(method="lm", color="grey66", fill= "grey88", alpha=0.4)+
  geom_point(data=dat.calib%>%filter(!row_number() %in% c(8)), aes(X.S.N..Amide...MC.in.vivo, Literature.MR..mL.O2...1.h...1.g.), color="blue")+
  geom_smooth(data=dat.calib%>%filter(!row_number() %in% c(8)), aes(X.S.N..Amide...MC.in.vivo, Literature.MR..mL.O2...1.h...1.g.), color="slateblue", method="lm")+
  theme_classic()+
  labs(x=expression(paste("Relative Intensity ([S-hcs] + [N-hcs]) x ", Amide^{-1})), y= expression(paste("Mass-Specific MR (", O[2]*h^-1*g^-1, ")")))+
  geom_label(
    label="r2 = 0.04 \n corrected", 
    x=10,
    y=1.5,
    label.padding = unit(0.2, "lines"), # Rectangle size around label
    label.size = 0.1,
    color = "black",
    fill="slateblue1",
    alpha=0.4
  )+
  geom_label(
    label="r2 = 0.83 \n uncorrected", 
    x=10,
    y=10,
    label.padding = unit(0.2, "lines"), # Rectangle size around label
    label.size = 0.2,
    color = "black",
    fill="grey88"
  )
```

Grey line shows original calibration linear model with SE bands. Purple line shows corrected linear model with SE bands. The relationship all but disappears after correcting the duck point... 



## Second calibration for extant taxa
It appears there were two calibrations(?) One for fossil taxa above and one for extant taxa (See Figure S7 and 'Extant Taxa' tab from supplementary workbook from Weimann et al. 2022)

They regressed n=25 literature MR values (not cited??) from spectral Amide ( _MC in vivo_) values from museum samples. We know from the literature that again this duck point ( _Dendrocygna_) cannot be correct (much higher than hummingbird). So, in absence of the known lit-derived value we will remove this point from our calibration. Second, we can see and suspect intense phylogenetic signal within this calibration and would like to correct for it. We will use the tree that Weimann _et al._ used to run a PGLS model.

```{r, echo=F}

lm.calib.extant <-dat.calib.extant%>%
  lm(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., data=.)

summary(lm.calib.extant)
# this is where they derive the formula for calculated MR ((9.5273 * Amide) -8.0604 and then corrected MR just add 0.9

#Remove the obviously incorrect duck point

dat.calib.extant <- dat.calib.extant%>% filter(!Taxon.Name %in% c("Dendrocygna"))


lm.calib.extant.rm <-dat.calib.extant%>%
   lm(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., data=.)
# 
 summary(lm.calib.extant.rm)

# This slightly changes our calibration for calculated MR to ((7.867 * Amide) - 6.141. 
```

## Phylogentic Least Squares Model for Extant Calibration
### PGLS using Time tree from Weimann _et al._ 2022 (Iris Mendez' Github)
```{r, echo=F, warning=F, message=F}
#Plot phylo real quick
#plot(tree, cex=0.2)

#need to create subtree with only extant taxa (this is tree from Iris Mendez' Github)
ext.tree <- keep.tip(tree, as.character(dat.calib.extant$Taxon.Name))



#also use tree from: http://timetree.org/ 
#Remove the underscore
tree.tt$tip.label <-gsub("\\_.*","",tree.tt$tip.label)
tree.tt$tip.label[tree.tt$tip.label=="Eudromia"]  <- "Crypturellus"
tree.tt$tip.label[tree.tt$tip.label=="Ornithorhynchus"]  <- "Platypus"
tree.tt$tip.label[tree.tt$tip.label=="Setifer"]  <- "Tenrec"
tree.tt$tip.label[tree.tt$tip.label=="Antrozous"]  <- "Anthrozous"



#get data in simplified format with taxon as rownames
pgls.dat <- dat.calib.extant%>%
  dplyr::select(Taxon.Name, Literature.MR..mL.O2...1.h...1.g., X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities.)%>%
  column_to_rownames(., "Taxon.Name")

pgls.dat$Taxon.Name <- dat.calib.extant$Taxon.Name

#is the tree ultrametric?
#is.ultrametric(tree.tt)
#yep!

#have to make a second one to match order of tips in time tree
tiporder <- tree.tt$tip.label
pgls.dat2 <-pgls.dat[tiporder,]

# Since we do not have an ultrametric tree here we need to specify weights as per Liam Revell here: http://blog.phytools.org/2012/04/using-nlmegls-for-phylogenetic.html

# compute weights
w<-diag(vcv.phylo(ext.tree))

#PGLS

#Pagel correlation structure
#lamda = 1 #pure Brownian motion; high phylo signal
pglsModel.pgl.1 <- gls(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., correlation = corPagel(1,  ext.tree, form = ~Taxon.Name, fixed=T), weights=varFixed(~w),
    data = pgls.dat, method = "REML")

summary(pglsModel.pgl.1)

```
We see that a pure Brownian Motion model with high phylo signal and _Dendrocygna_ removed reduces the slope of the extant calibration from 9.5273 to 5.915003 and increases the intercept from -8.0604 to -3.937516. 

Next we will run a model with a starting value of _lamda_ at zero.

```{r, echo=F, warning=F, message=F}
#lamda = 0 #Low phylo signal, just plain old regression
pglsModel.pgl.0 <- gls(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., correlation = corPagel(0,  ext.tree, form = ~Taxon.Name), weights=varFixed(~w),
    data = pgls.dat, method = "REML")

summary(pglsModel.pgl.0)

```
We see that a pure Brownian Motion model with high phylo signal  and _Dendrocygna_ removed reduces the slope of the extant calibration from 9.5273 to 7.414920 and increases the intercept from -8.0604 to -5.627356. The model estimates _lamda_ at 0.17, pretty low phylo signal. 


```{r, echo=F, warning=F, message=F}
anova(pglsModel.pgl.0, pglsModel.pgl.1)

#Indicates low phylo signal; use pglsModel.pgl.0 as correction
```

Models selection favors the low phylo signal model.

```{r, echo=F, warning=F, message=F}
fits <- as.data.frame(pglsModel.pgl.0$fitted)
colnames(fits) <- "fitted"
fits$Amide <-pgls.dat$X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities.
fits$fitted2 <- pglsModel.pgl.1$fitted

ggplot(fits, aes(Amide, fitted))+
  geom_point()+
  geom_smooth(method=lm, se=F)+
  geom_smooth(aes(y=fitted2),method=lm, se=F, color="goldenrod")+
  geom_smooth(data=pgls.dat, aes(x=X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., y=Literature.MR..mL.O2...1.h...1.g.), method=lm, se=F, color="black")+
  geom_point(data=pgls.dat, aes(x=X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., y=Literature.MR..mL.O2...1.h...1.g.))+
  theme_classic(base_size = 14)+
  labs(x="Amide", y="PGLS fitted MC in vivo")

```
This plot shows the two PGLS regression lines from the tree they used for their figures, ancestral state reconstruction and, presumably, PGLS. The black line is just uncorrected linear model. The blue line is essentially identical to uncorrected linear regression.This is the line supported by model selection. The yellow line is the model forcing a high level of phylo signal ( _lamda_ = 1).This line is not suported. _Lamda_ is estimated at ~ 0.17 by "best" model.

 
### PGLS using Time tree from timetree.org
```{r, echo=FALSE, warning=F, message=F}

# compute weights
w2<-diag(vcv.phylo(tree.tt))

#Pagel correlation structure
#lamda = 1 #pure Brownian motion; high phylo signal
tt.pgl.1 <- gls(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., correlation = corPagel(1,  tree.tt, form = ~Taxon.Name, fixed=T),
    data = pgls.dat2, method = "REML")

summary(tt.pgl.1)

```
We see that a pure Brownian Motion model with high phylo signal  and _Dendrocygna_ removed reduces the slope of the extant calibration from 9.5273 to 6.284117 and increases the intercept from -8.0604 to -4.332293 

Next we will run a model with a starting value of _lamda_ at zero.

```{r, echo=F, warning=F, message=F}
#lamda = 0 #Low phylo signal, just plain old regression
tt.pgl.0 <- gls(Literature.MR..mL.O2...1.h...1.g. ~ X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., correlation = corPagel(0,  tree.tt, form = ~Taxon.Name),
    data = pgls.dat2, method = "REML")

summary(tt.pgl.0)

```

We see that a pure Brownian Motion model with high phylo signal  and _Dendrocygna_ removed reduces the slope of the extant calibration from 9.5273 to 7.998161 and increases the intercept from -8.0604 to -6.310608 

```{r, echo=F, warning=F, message=F}
anova(tt.pgl.0, tt.pgl.1)

#Indicates low phylo signal; use tt.pgl.1 as correction
```

So, we need to use the low phylosignal model which changes the original slope from 9.5273 to 7.998161  and increases the intercept from -8.0604 to -6.310608 

```{r, echo=F, warning=F, message=F}
fits <- as.data.frame(tt.pgl.0$fitted)
colnames(fits) <- "fitted"
fits$Amide<-pgls.dat2$X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities.
fits$fitted2 <-(tt.pgl.1$fitted)


ggplot(fits, aes(Amide, fitted))+
  geom_smooth(method=lm, se=F)+
  geom_smooth(aes(y=fitted2), method=lm, se=F, color="goldenrod")+
  geom_smooth(data=pgls.dat2, aes(x=X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., y=Literature.MR..mL.O2...1.h...1.g.), method=lm, se=F, color="black")+
  geom_point(data=pgls.dat2, aes(x=X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., y=Literature.MR..mL.O2...1.h...1.g.))+
  theme_classic(base_size = 14)+
  labs(x="Literature MR", y="PGLS fitted MC in vivo")

```
This plot shows the two PGLS regression lines from the timetree pgls. The black line is just regular linear model. The blue line (barely visible) is essentially identical to uncorrected linear regression.This is the line supported by model selection. The yellow line is the model forcing a high level of phylo signal ( _lamda_ = 1).This line is not supported. _Lamda_ is estimated at ~ 0.


Therefore, we will give them the benefit  of the doubt and use the time tree pgls with _Dendrocygna_ removed. This flattens slope slightly changing calibration formula from (9.527 * _MC in vivo_) - 8.060 to (7.998161 * _MC in vivo_) - 6.310608 for all extant taxa. 

```{r}
# Add corrected columns for adjusted calcuatedMR and corrected
# We will give them the benefit  of the doubt and use the time tree pgls with Dendrocygna removed. This flattens slope slighlty...

 dat.calib.extant$adj_calc_MR <-(7.998161*dat.calib.extant$X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities.)-6.310608
 dat.calib.extant$adj_corr_MR <-dat.calib.extant$adj_calc_MR +0.9

#This is for fun to see what applying the fossil calibration (since they used extant MRs anyway) to all extant taxa
dat.calib.extant$adj_calc_MR_foss_cab <-(0.3207*dat.calib.extant$X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities.)+0.3371
dat.calib.extant$adj_corr_MR_foss_cab <-dat.calib.extant$adj_calc_MR_foss_cab +0.9

```


```{r, echo=F, message=F, eval=F}
# ggplot(data=dat.calib.extant%>%filter(!row_number() %in% c(26)), aes(X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., Literature.MR..mL.O2...1.h...1.g.))+
#   geom_point()+
#   geom_smooth(method="lm", color="grey66", fill= "grey88", alpha=0.4)+
#   geom_point(data=dat.calib.extant%>%filter(!row_number() %in% c(8)), aes(X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., Literature.MR..mL.O2...1.h...1.g.), color="blue")+
#   geom_smooth(data=dat.calib.extant%>%filter(!row_number() %in% c(8)), aes(X.S.N..Amide...MC.in.vivo..normalized.spectral.intensities., Literature.MR..mL.O2...1.h...1.g.), color="slateblue", method="lm")+
#   theme_classic()+
#   labs(x=expression(paste("Relative Intensity ([S-hcs] + [N-hcs]) x ", Amide^{-1})), y= expression(paste("Mass-Specific MR (", O[2]*h^-1*g^-1, ")")))+
#   geom_label(
#     label="r2 = 0.21 \n
#     corrected", 
#     x=1.6,
#     y=2.5,
#     label.padding = unit(0.2, "lines"), # Rectangle size around label
#     label.size = 0.1,
#     color = "black",
#     fill="slateblue1",
#     alpha=0.4
#   )+
#   geom_label(
#     label="r2 = 0.66 \n uncorrected", 
#     x=1.6,
#     y=10,
#     label.padding = unit(0.2, "lines"), # Rectangle size around label
#     label.size = 0.2,
#     color = "black",
#     fill="grey88"
#   )
```

# Apply fossil calibration and plot it
```{r, echo=F, , fig.show="hold", out.width="50%"}
dat.calib.fossil[31,1]<- dat.calib.fossil[1,1]
dat.calib.fossil[31,8]<- dat.calib.fossil[1,8]
dat.calib.fossil[31,9]<- 2.35


#summary(lm.calib.rm)
#  This is how fossils were calibrated (0.3207*Fossil Amide here)-0.3371
#with added uncertainty add 1.2 to the value calculated above
#use the above equation to produce corrected fossil MR estimates
dat.calib.fossil$adj_calc_MR <- (0.3207*dat.calib.fossil$X.S.N..Amide..normalized.spectral.intensities....MC.in.vivo) +0.3371
dat.calib.fossil$adj_corr_MR <- dat.calib.fossil$adj_calc_MR+ 1.2

dat.calib.fossil$adj_calc_MR_foss_cab <- (0.3207*dat.calib.fossil$X.S.N..Amide..normalized.spectral.intensities....MC.in.vivo) +0.3371
dat.calib.fossil$adj_corr_MR_foss_cab <- dat.calib.fossil$adj_calc_MR_foss_cab + 1.2


#remove the first row Anseriform Bird 

dat.calib.fossil.2 <- dat.calib.fossil%>%
  slice(2:31)%>%
  dplyr::select(Taxon, adj_calc_MR, adj_corr_MR, adj_calc_MR_foss_cab, adj_corr_MR_foss_cab) #select only columns needed for plotting

dat.calib.extant.2 <- dat.calib.extant%>%
  #filter(!row_number() %in% c(8))%>%
  dplyr::select(Taxon.Name, adj_calc_MR, adj_corr_MR, adj_calc_MR_foss_cab, adj_corr_MR_foss_cab)%>%#select only columns needed for plotting
  dplyr::rename(Taxon=Taxon.Name)

full.analyses.df <- rbind(dat.calib.fossil.2, dat.calib.extant.2)

body.masses <- dat.lm$Body.mass..g.
full.analyses.df<-full.analyses.df%>%
  left_join(., dat.lm, by="Taxon")
full.analyses.df$Mass.Spec.MR.corr <- (full.analyses.df$Body.mass..g.* full.analyses.df$adj_corr_MR)
full.analyses.df$Log.10.MR.corr <- log10(full.analyses.df$Mass.Spec.MR.corr)

full.analyses.dfMass.Spec.MR.corr.foss.cab <- (full.analyses.df$Body.mass..g.* full.analyses.df$adj_corr_MR_foss_cab)
full.analyses.df$Log.10.MR.corr.foss.cab <- log10(full.analyses.df$Mass.Spec.MR.corr)

#endotherm model where we apply fossil calibration to all data
end.mod.foss.cab <- full.analyses.df%>%
  filter(classification=="endo",
         Age=="Extant")%>%
  lm(Log.10.MR.corr.foss.cab ~Log.10..Body.Mass..g., data=.)

temp_var_endo_foss_cab <- predict(end.mod.foss.cab, interval="prediction")

new_df_endo_foss_cab <- cbind(full.analyses.df%>%
  filter(classification=="endo",
         Age=="Extant"), temp_var_endo_foss_cab)

#endotherm model with separate fossil and extant calibration as above and in Weimann et al. 2022
end.mod2 <- full.analyses.df%>%
  filter(thermy=="endo")%>%
  lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=.)

newdata <- full.analyses.df%>% dplyr::select(Log.10..Body.Mass..g.)

temp_var_endo_PI <- predict(end.mod2, newdata=newdata, interval="prediction", level=0.95)
temp_var_endo_CI <- predict(end.mod2, newdata=newdata, interval="confidence", level=0.95)

new_df_endo_PI <- cbind(full.analyses.df, temp_var_endo_PI)
new_df_endo_CI <- cbind(full.analyses.df, temp_var_endo_CI)

#other therm model with extant and fossil calibration to generate PI and CI
oth.mod2 <- full.analyses.df%>%
  filter(classification %in%  c("ecto","meso", "oth"),
         Age=="Extant")%>%
  lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=.)

temp_var_oth_PI <- predict(oth.mod2, newdata=newdata, interval="prediction", level=0.95)
new_df_oth_PI <- cbind(full.analyses.df, temp_var_oth_PI)


p1<-ggplot(full.analyses.df, aes(Log.10..Body.Mass..g., Log.10.MR.corr))+
  geom_point(aes(fill=thermy, color=Age),shape=21)+
  geom_smooth(data=full.analyses.df%>%filter(thermy=="endo"), aes(Log.10..Body.Mass..g., Log.10.MR.corr), method="lm", fill="goldenrod2", color="goldenrod3")+
  geom_smooth(data=dat.lm%>%filter(thermy=="endo"), aes(Log.10..Body.Mass..g., Log.10..Upper.MR), method="lm", se=T, color="black", linetype="dashed")+
  geom_line(data=new_df_endo_PI,aes(y=lwr), color = "goldenrod", linetype = "dashed")+
  geom_line(data=new_df_endo_PI, aes(y=upr), color = "goldenrod", linetype = "dashed")+
  geom_line(data=orig_df_endo,aes(y=lwr), color = "grey77", linetype = "dashed")+
  geom_line(data=orig_df_endo, aes(y=upr), color = "grey77", linetype = "dashed")+
  #geom_line(data=orig_df_oth,aes(y=lwr), color = "dodgerblue", linetype = "dashed")+
  #geom_line(data=orig_df_oth, aes(y=upr), color = "dodgerblue", linetype = "dashed")+
  scale_color_manual(values=c("brown3", "black"))+
  scale_fill_manual(values=c("goldenrod", "dodgerblue"))+
  theme_classic(base_size = 14)+
  theme(legend.position = c(0.8,0.25)) 
  # geom_text(data=full.analyses.df, aes(label=Taxon), size=2.5,
  #   nudge_x = 0.2, nudge_y = 0.1, 
  #   check_overlap = T
  # )
  p1
  
  
  p2<-ggplot(full.analyses.df, aes(Log.10..Body.Mass..g., Log.10.MR.corr))+
  geom_point(aes(fill=thermy, color=Age),shape=21)+
  geom_smooth(data=full.analyses.df%>%
  filter(classification=="endo",
         Age=="Extant"), aes(Log.10..Body.Mass..g., Log.10.MR.corr), method="lm", fill="goldenrod2", color="black")+
  #geom_smooth(data=dat.lm%>%filter(thermy=="endo"), aes(Log.10..Body.Mass..g., Log.10..Upper.MR), method="lm", se=T, color="black", linetype="dashed")+
  geom_line(data=new_df_endo_PI,aes(y=lwr), color = "goldenrod", linetype = "dashed")+
  geom_line(data=new_df_endo_PI, aes(y=upr), color = "goldenrod", linetype = "dashed")+
  geom_line(data=new_df_oth_PI,aes(y=lwr), color = "dodgerblue", linetype = "dashed")+
  geom_line(data=new_df_oth_PI, aes(y=upr), color = "dodgerblue", linetype = "dashed")+
  scale_color_manual(values=c("brown3", "black"))+
  scale_fill_manual(values=c("goldenrod", "dodgerblue"))+
  theme_classic(base_size = 14)+
  theme(legend.position = c(0.8,0.25)) 
  # geom_text(data=full.analyses.df, aes(label=Taxon), size=2.5,
  #   nudge_x = 0.2, nudge_y = 0.1, 
  #   check_overlap = T
  # )
  p2
  
  
  
```

The effect of the adjusted calibration is shown here. *Left Panel* The original endotherm regression is dashed black here while the new one with adjusted calibration is dark yellow. The original endotherm PI is dashed grey and the adjusted endotherm PI is dashed yellow. At low masses they essentially predict the same MRs. *Right Panel* shows the overlap between prediction intervals for endotherms (yellow) and unknown therms (blue). Substantial overlap across entire range suggesting maybe 50/50 chance of correctly identifying thermy within this narrow range.



# Simulate data with adjusted calibration using faux package.
## Plot simulated data and overlap with CI
```{r, sim_df with `faux`, message=F, warning=F, echo=F}
iter <- 1000 #set number of iterations

#build list to store results
dfs <- vector("list", length = iter)

mods <- vector("list", length = iter)

Var.stats <- vector("list", length = iter)

dino.sim.results <- list(dfs, mods, Var.stats)

dat.sim.orig <-dat.lm%>%dplyr::select(Taxon, Age, thermy, Log.10..Upper.MR, Log.10..Body.Mass..g.)
dat.sim.adjust <-full.analyses.df%>%dplyr::select(Taxon, Age, thermy, Log.10.MR.corr, Log.10..Body.Mass..g.)

for(i in 1:iter){
  t.df <- sim_df(dat.sim.adjust, n=28, between=c("thermy"), empirical = T)
  t.df <-t.df%>%sample_n(size=55)
  t.lm <- lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=t.df)
  #t.endo.lm <- lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=t.df%>%filter(thermy=="endo"))
  #t.oth.lm <- lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=t.df%>%filter(thermy=="oth"))
 
  Var.stats <-tdStats(m = t.lm$fitted.values, o=t.lm[["model"]][[1]])

  #write new predicot variables from simulated dataframe
  newdata<- t.df%>%dplyr::select(Log.10..Body.Mass..g.)

  # generate prediction and confidence intervals for endotherms and othertherms from recalibrated endo and other models
  endo.CI<-predict(end.mod2, newdata=newdata, interval="confidence",level=0.95)
  #endo_ci_plt_data <- cbind(t.df%>%filter(thermy=="endo"), endo.CI)
  endo.PI<-predict(end.mod2, newdata=newdata,interval="prediction",level=0.95)
  oth.CI<-predict(oth.mod2, newdata=newdata,interval="confidence",level=0.95)
  #oth_ci_plt_data <- cbind(t.df%>%filter(thermy=="oth"), oth.CI)
  oth.PI<-predict(oth.mod2, newdata=newdata,interval="prediction",level=0.95)

  #check if simulated points fall within endo CI and PI
  t.df$in_endo_CI <-rep(1,nrow(t.df))
  t.df$in_endo_CI[t.df$Log.10.MR.corr<endo.CI[,2]| t.df$Log.10.MR.corr>endo.CI[,3]]=0
  t.df$in_endo_PI <-rep(1,nrow(t.df))
  t.df$in_endo_PI[t.df$Log.10.MR.corr<endo.PI[,2] | t.df$Log.10.MR.corr>endo.PI[,3]]=0
  
  #check if simulated points fall within endo CI and PI
  t.df$in_oth_CI <-rep(1,nrow(t.df))
  t.df$in_oth_CI[t.df$Log.10.MR.corr<oth.CI[,2] | t.df$Log.10.MR.corr>oth.CI[,3]]=0
  t.df$in_oth_PI <-rep(1,nrow(t.df))
  t.df$in_oth_PI[t.df$Log.10.MR.corr<oth.PI[,2] | t.df$Log.10.MR.corr>oth.PI[,3]]=0
  
  #Test plot for loop eval:
  ggplot(t.df, aes(Log.10..Body.Mass..g., Log.10.MR.corr, color=factor(in_endo_CI)))+
    geom_point()+
    geom_line(data= new_df_endo_CI,aes(y=lwr), color = "goldenrod", linetype = "dashed")+
  geom_line(data=new_df_endo_CI, aes(y=upr), color = "goldenrod", linetype = "dashed")
  
  #set iteration variable for later analysis
  t.df$iteration <-i
  
  dino.sim.results[[1]][[i]] <- t.df
  dino.sim.results[[2]][[i]] <- t.lm
  dino.sim.results[[3]][[i]] <- Var.stats
}





ploters <-  do.call("rbind", dino.sim.results[[1]])

ggplot(ploters, aes(Log.10..Body.Mass..g., Log.10.MR.corr, fill=factor(in_endo_PI)))+
  geom_point(shape=21,size=0.7)+
  scale_fill_manual(values=c("grey88", "grey22"), labels=c("outside endotherm PI", "in endotherm PI"))+
  theme_classic(base_size = 14)+
  facet_wrap(~thermy)+
  theme(legend.position = c(0.9, 0.2),
        legend.title = element_blank())

```
So here we used the package `faux` to simulate data from our model with a corrected fossil calibration. We simulate n=100 dataframes and ask whether or not the simulated data fall within endotherm and othertherm 95% CI and PIs from the corrected _MC in vivo_ values using the adjusted fossil calibration.The plot simply shows all simulated data from 1000 iterations colored by whether or not points fell within the 95% CI for endotherms and othertherms.

## Plot classification success

Let's look at percentages of points classified as endotherm or other following the Weimann et al. 2022 schema.

```{r, message=F, echo=F, warning =F}

ploters%>%group_by(iteration, thermy)%>%
  summarise(cnt=n(),
            perc_in_endo_PI=sum(in_endo_PI)/cnt,
            perc_in_oth_PI=sum(in_oth_PI)/cnt)%>%
  gather(measure, percent, -iteration, -cnt, -thermy)%>%
  ggplot(., aes(percent, measure))+
  geom_density_ridges(quantile_lines=T,quantiles=2)+
  scale_y_discrete(labels=c( "% classified as endotherm \n 95% PI", "% classified as other \n 95% PI"))+
  theme_classic(base_size = 14)+
  facet_wrap(~thermy)
  
```

Here are distributions of percentages of simulated data points that fell within the 95% confidence interval (CI) or prediction interval (PI) for endotherms and amniotes of other/indeterminate thermy. Keep in mind that the simulated data follow the exact same means, standard deviations, and correlations as original data.
 
  
```{r, eval=F, echo=F}
var_stats <-  as.data.frame(do.call("rbind", dino.sim.results[[3]]))

ggplot(var_stats, aes(cvrmse))+
  geom_density(fill="dodgerblue")
  
# When I don't simualte data with the exact same variance mean and correlations we tend to have lower CVRMSE than the original dataset...
```


# Simulate data with adjusted calibration using MASS package.

```{r, sim_df with `MASS`, message=F, warning=F, echo=F}

#First get some Means and variances by Age and thermy for the dataset

full.analyses.df%>%
  group_by(termy_3_cat)%>%
  summarize(mean.mass = mean(Log.10..Body.Mass..g.),
            var.mass = var(Log.10..Body.Mass..g.),
            mean.mr = mean(Log.10.MR.corr),
            var.mr = var(Log.10.MR.corr),
            cnt=n())



#create correlation structure for known endotherm simulated points
cov(full.analyses.df%>%filter(termy_3_cat=="known endotherm")%>%dplyr::select(Log.10..Body.Mass..g.), full.analyses.df%>%filter(termy_3_cat=="known endotherm")%>%dplyr::select(Log.10.MR.corr))
mt.dt.endo <- c(2.37, 2.32094, 2.32094, 2.28)
cv.mat.endo <- matrix(data = mt.dt.endo, nrow = 2, ncol = 2, byrow = TRUE)
rownames(cv.mat.endo) <- c("Log.10..Body.Mass..g.", "Log.10.MR.corr")
colnames(cv.mat.endo) <- c("Mass", "MR")
endo.means <- c(3.37, 3.98)

#create correlation structure for known other simulated points
cov(full.analyses.df%>%filter(termy_3_cat=="known other")%>%dplyr::select(Log.10..Body.Mass..g.), full.analyses.df%>%filter(termy_3_cat=="known other")%>%dplyr::select(Log.10.MR.corr))
mt.dt.oth <- c(0.658, 0.6648198, 0.6648198, 0.706)
cv.mat.oth <- matrix(data = mt.dt.oth, nrow = 2, ncol = 2, byrow = TRUE)
rownames(cv.mat.oth) <-  c("Log.10..Body.Mass..g.", "Log.10.MR.corr")
colnames(cv.mat.oth) <- c("Mass", "MR")
oth.means <- c(2.97, 3.39)


#create correlation structure for unknown simulated points
cov(full.analyses.df%>%filter(termy_3_cat=="unknown")%>%dplyr::select(Log.10..Body.Mass..g.), full.analyses.df%>%filter(termy_3_cat=="unknown")%>%dplyr::select(Log.10.MR.corr))
mt.dt.unk <- c(2.45, 2.515305, 2.515305, 2.59)
cv.mat.unk <- matrix(data = mt.dt.unk, nrow = 2, ncol = 2, byrow = TRUE)
rownames(cv.mat.unk) <-  c("Log.10..Body.Mass..g.", "Log.10.MR.corr")
colnames(cv.mat.unk) <- c("Mass", "MR")
unk.means <- c(5.80, 6.28)


iter <- 1000 #set number of iterations

#build list to store results
dfs <- vector("list", length = iter)

mods <- vector("list", length = iter)

Var.stats <- vector("list", length = iter)


dino.sim.results <- list(dfs, mods, Var.stats)


for(i in 1:iter){
  t.df.1 <- as.data.frame(mvrnorm(n=28, mu=endo.means, Sigma = cv.mat.endo))
  t.df.1$thermy <-"endo"
  
    
  t.df.2 <- as.data.frame(mvrnorm(n=13, mu=oth.means, Sigma = cv.mat.oth))
  t.df.2$thermy <-"oth"

    
    
    #Sigma <- make.positive.definite (cv.mat.unk, tol = 1e-3)
  t.df.3 <- as.data.frame(mvrnorm(n=13, mu=unk.means, Sigma = cv.mat.unk))
  t.df.3$thermy <-"unkown"
    

    t.df <- rbind(t.df.1, t.df.2, t.df.3)
  
  t.lm <- lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=t.df)
  #t.endo.lm <- lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=t.df%>%filter(thermy=="endo"))
  #t.oth.lm <- lm(Log.10.MR.corr ~Log.10..Body.Mass..g., data=t.df%>%filter(thermy=="oth"))
 
  Var.stats <-tdStats(m = t.lm$fitted.values, o=t.lm[["model"]][[1]])

  #write new predicot variables from simulated dataframe
  newdata<- t.df%>%dplyr::select(Log.10..Body.Mass..g.)

  # generate prediction and confidence intervals for endotherms and othertherms from recalibrated endo and other models
  endo.CI<-predict(end.mod2, newdata=newdata, interval="confidence",level=0.95)
  #endo_ci_plt_data <- cbind(t.df%>%filter(thermy=="endo"), endo.CI)
  endo.PI<-predict(end.mod2, newdata=newdata,interval="prediction",level=0.95)
  oth.CI<-predict(oth.mod2, newdata=newdata,interval="confidence",level=0.95)
  #oth_ci_plt_data <- cbind(t.df%>%filter(thermy=="oth"), oth.CI)
  oth.PI<-predict(oth.mod2, newdata=newdata,interval="prediction",level=0.95)

  #check if simulated points fall within endo CI and PI
  t.df$in_endo_CI <-rep(1,nrow(t.df))
  t.df$in_endo_CI[t.df$Log.10.MR.corr<endo.CI[,2]| t.df$Log.10.MR.corr>endo.CI[,3]]=0
  t.df$in_endo_PI <-rep(1,nrow(t.df))
  t.df$in_endo_PI[t.df$Log.10.MR.corr<endo.PI[,2] | t.df$Log.10.MR.corr>endo.PI[,3]]=0
  
  #check if simulated points fall within endo CI and PI
  t.df$in_oth_CI <-rep(1,nrow(t.df))
  t.df$in_oth_CI[t.df$Log.10.MR.corr<oth.CI[,2] | t.df$Log.10.MR.corr>oth.CI[,3]]=0
  t.df$in_oth_PI <-rep(1,nrow(t.df))
  t.df$in_oth_PI[t.df$Log.10.MR.corr<oth.PI[,2] | t.df$Log.10.MR.corr>oth.PI[,3]]=0
  
  #Test plot for loop eval:
  # ggplot(t.df, aes(Log.10..Body.Mass..g., Log.10.MR.corr, color=factor(in_endo_CI)))+
  #   geom_point()+
  #   geom_line(data= new_df_endo_CI,aes(y=lwr), color = "goldenrod", linetype = "dashed")+
  # geom_line(data=new_df_endo_CI, aes(y=upr), color = "goldenrod", linetype = "dashed")
  
  #set iteration variable for later analysis
  t.df$iteration <-i
  
  dino.sim.results[[1]][[i]] <- t.df
  dino.sim.results[[2]][[i]] <- t.lm
  dino.sim.results[[3]][[i]] <- Var.stats
}


ploters <-  do.call("rbind", dino.sim.results[[1]])

```

## Plot simulated data and overlap with CI
```{r, echo=F, message=F, warning=F}
ggplot(ploters, aes(Log.10..Body.Mass..g., Log.10.MR.corr, fill=factor(in_oth_PI)))+
  geom_point(shape=21,size=0.7)+
 # scale_fill_manual(values=c("grey88", "grey22"))+
  theme_classic(base_size = 14)+
  facet_wrap(~thermy)

```
Same thing as above but using package `MASS` (a bit more control/diy) to simulate data from our model with a corrected fossil calibration. We simulate n=1000 dataframes and ask whether or not the simulated data fall within endotherm and othertherm 95% CI and PIs from the corrected _MC in vivo_ values using the adjusted fossil calibration.The plot simply shows all simulated data from 100 iterations colored by whether or not points fell within the 95% CI for endotherms and othertherms.


## Plot classification success

Let's look at percentages of points classified as endotherm or other following the Weimann et al. 2022 schema.

```{r, echo=F, message=F}

ploters%>%group_by(iteration, thermy)%>%
  summarise(cnt=n(),
            perc_in_endo_PI=sum(in_endo_PI)/cnt,
            perc_in_oth_PI=sum(in_oth_PI)/cnt,)%>%
  gather(measure, percent, -iteration, -cnt, -thermy)%>%
  ggplot(., aes(percent, measure))+
  geom_density_ridges(quantile_lines=T,quantiles=2)+
  scale_y_discrete(labels=c( "% classified as endotherm \n 95% PI",  "% classified as other \n 95% PI"))+
  theme_classic(base_size = 14)+
  facet_wrap(~thermy)
  
```

Here are distributions of percentages of simulated data points that fell within the 95% confidence interval (CI) or prediction interval (PI) for endotherms and amniotes of other/indeterminate thermy. Keep in mind that the simulated data follow the exact same means, standard deviations, and correlations as original data.

```{r, echo=F}
ploters%>%group_by(thermy)%>%
  summarise(cnt=n(),
            perc_in_endo_PI=sum(in_endo_PI)/cnt,
            perc_in_oth_PI=sum(in_oth_PI)/cnt)
      
```

```{r, eval=F, echo=F}

var_stats <-  as.data.frame(do.call("rbind", dino.sim.results[[3]]))

ggplot(var_stats, aes(cvrmse))+
  geom_density(fill="dodgerblue")
  
# When I don't simulate data with the exact same variance mean and correlations we tend to have lower CVRMSE than the original dataset...
```


# In light of John Grady's framework 

Finally, we use John Grady's conceptual framework to test whether the mass specific MR shows the expected decrease with body mass or is flat consistent wiht the canceling effects of lifespan and cell metabolic rate. 

## Plot mass-specific MR x mass for orginal and recalibrated data:
```{R, echo=F, fig.show="hold", out.width="50%"}


p1<-ggplot(dat.lm, aes(Log.10..Body.Mass..g., log10(Calculated.MRs..mL.O2...1.h...1.g.)))+
  geom_point()+
 # geom_smooth(method="lm", color="black", alpha=0.2)+
   geom_smooth(aes(color=thermy),method="lm", alpha=0.2)+
  theme_classic(base_size = 14)+
  scale_color_manual(values=c("red", "blue"))+
  theme_classic(base_size = 14)+
  labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Mass-Specific MR (", O[2]*h^-1*g^-1, ")")))+
  theme(legend.title = element_blank(), 
        legend.position = c(0.8,0.2))
p1

mod.mass.endo<-lm(log10(Calculated.MRs..mL.O2...1.h...1.g.)~log10(Body.mass..g.), data=dat.lm %>% filter(thermy%in%("endo")))
summary(mod.mass.endo)

mod.mass.ecto<-lm(log10(Body.mass..g.)~log10(Calculated.MRs..mL.O2...1.h...1.g.) , data=dat.lm %>% filter(thermy%in%("oth")))
summary(mod.mass.ecto)


lm.lg10.endo <- lm(log10(adj_corr_MR) ~ Log.10..Body.Mass..g., full.analyses.df%>%filter(classification=="endo"))

lg10.endo.pred <- predict(lm.lg10.endo, interval="prediction")

lg10.endo.pred <- cbind(full.analyses.df%>%filter(classification=="endo"), lg10.endo.pred)

lm.lg10.ecto <- lm(log10(adj_corr_MR)  ~ Log.10..Body.Mass..g., full.analyses.df%>%filter(classification=="ecto"))

lg10.ecto.pred <- predict(lm.lg10.ecto, interval="prediction")

lg10.ecto.pred <- cbind(full.analyses.df%>%filter(classification=="ecto"), lg10.ecto.pred)

#Make total adjusted MR
full.analyses.df <- full.analyses.df%>%
  mutate(Log10_total_adj_corr_MR = log10(Body.mass..g.*adj_corr_MR))


p2<-ggplot(full.analyses.df%>%filter(classification%in%c("endo","ecto")), aes(Log.10..Body.Mass..g., log10(adj_corr_MR)))+
  geom_point(aes(color=classification), alpha=0.5)+
  geom_point(data=full.analyses.df%>%filter(classification%in%c("oth")), color="gray", alpha=0.5)+
  #geom_smooth(method="lm", alpha=0.2, color="black")+
  geom_smooth(aes(color=classification),method="lm", alpha=0.2, se=F)+
  scale_color_manual(values=c("blue", "red", "black"))+
   geom_line(data=lg10.endo.pred,aes(y=lwr), color = "red", linetype = "dashed")+
    geom_line(data=lg10.endo.pred, aes(y=upr), color = "red", linetype = "dashed")+
  geom_line(data=lg10.ecto.pred,aes(y=lwr), color = "blue", linetype = "dashed")+
    geom_line(data=lg10.ecto.pred, aes(y=upr), color = "blue", linetype = "dashed")+
  theme_classic(base_size = 14)+
  labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Mass-Specific MR (", O[2]*h^-1, ")")))+
  theme(legend.title = element_blank(), 
        legend.position = c(0.8,0.2))+
  stat_regline_equation(label.y = 0.8, aes(label = ..eq.label..))
p2

full.analyses.df%>%filter(classification=="endo")%>%lm(log10(adj_corr_MR)~ Log.10..Body.Mass..g., data=.)%>%summary(.)
full.analyses.df%>%filter(classification=="ecto")%>%lm(log10(adj_corr_MR)~ Log.10..Body.Mass..g., data=.)%>%summary(.)


```
*Left Panel* shows Mass-specific MR by body mass for original uncorrected data from Weimann _et al._ 2022. *Left Panel* shows same relationship but with re-calibrated data. The black lines are linear models plotted with gray SE bands for combined data. Yellow and blue lines are separate regressions for endo and unknown therms respectively. Notice uncorrected data has no relationship. Corrected data shows slight negative trend but not significant _P_ = 0.08. This slight downward trend is driven by separation in endo (yellow) and other (yellow) points which have significantly different intercepts but essentially 100% correlated with Age and therefore the separate calibrations.


```{r, eval=F, echo=F}
#This chunk juste used to make Figure 1
p<-sim.point.reg(slope = 0, xlwr = min(full.analyses.df$Log.10..Body.Mass..g.), xupr = max(full.analyses.df$Log.10..Body.Mass..g.), ylwr=-0.5, yupr = 2, intercept=0.45, add_line = 0.1)
p <- p + labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Response")))
p


p2<-sim.point.reg(slope = -0.25, xlwr = min(full.analyses.df$Log.10..Body.Mass..g.), xupr = max(full.analyses.df$Log.10..Body.Mass..g.), ylwr=-0.5, yupr = 2, intercept=2, add_line = 0.1)
p2 <- p2 + labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Response")))
p2

p3<-sim.point.reg(slope = 0.25, xlwr = min(full.analyses.df$Log.10..Body.Mass..g.), xupr = max(full.analyses.df$Log.10..Body.Mass..g.), ylwr=-0.5, yupr = 2, intercept=0, add_line = -0.1)
p3 <- p3 + labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Response")))

p3

p4<-ggplot(full.analyses.df%>%filter(classification%in%c("endo","ecto")), aes(Log.10..Body.Mass..g., log10(adj_corr_MR)))+
  geom_point(aes(color=classification), alpha=0.5)+
  geom_point(data=full.analyses.df%>%filter(classification%in%c("oth")), color="gray", alpha=0.5)+
  #geom_smooth(method="lm", alpha=0.2, color="black")+
  geom_smooth(aes(color=classification),method="lm", alpha=0.2, se=F)+
  scale_color_manual(values=c("blue", "red", "black"))+
   geom_line(data=lg10.endo.pred,aes(y=lwr), color = "red", linetype = "dashed")+
    geom_line(data=lg10.endo.pred, aes(y=upr), color = "red", linetype = "dashed")+
  geom_line(data=lg10.ecto.pred,aes(y=lwr), color = "blue", linetype = "dashed")+
    geom_line(data=lg10.ecto.pred, aes(y=upr), color = "blue", linetype = "dashed")+
  theme_classic(base_size = 14)+
  labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"(Mass-Specific MR (", O[2]*h^-1, "))")))+
  theme(legend.title = element_blank(), 
        legend.position = "none")+
  scale_y_continuous(limits = c(-0.5,2))+
  stat_regline_equation(label.y = 1.5, aes(label = ..eq.label..))
p4

gridExtra::grid.arrange(p2, p3, p, p4, nrow=2)

```

## Plot mass-specific MR x mass for extant calibration data:

```{R, echo=F}


p<-ggplot(dat.lm%>%filter(Age=="Extant"), aes(log10(Body.mass..g.), log10(Calculated.MRs..mL.O2...1.h...1.g. +1), color=thermy_3_cat))+
  geom_point()+
  #geom_smooth(method="lm",  se=F, alpha=0.2, color="black", linetype="dashed")+
  geom_smooth(data=dat.lm%>%filter(Age=="Extant", thermy_3_cat=="known endotherm"),method="lm", color= "red", alpha=0.2)+
  geom_smooth(data=dat.lm%>%filter(Age=="Extant", thermy_3_cat=="known other"),method="lm", color= "blue", alpha=0.2)+
  #scale_color_manual(values=c("red", "blue"))+
  theme_classic(base_size = 14)+
  labs(x=expression(paste(Log["10"]~Body~Mass~(g))), y= expression(paste(Log["10"]~"Mass-Specific MR (", O[2]*h^-1*g^-1, ")")))+
  theme(legend.title = element_blank(), 
        legend.position = c(0.8,0.2))+
  geom_text(data=dat.lm%>%filter(Age=="Extant"), aes(label=Taxon), size=2.5,
    nudge_x = 0.1, nudge_y = 0.05, 
    check_overlap = T
  )
p

dat.lm%>%filter(Age=="Extant")%>%lm(log10(Body.mass..g.)~log10(Calculated.MRs..mL.O2...1.h...1.g.), data=.)%>%summary(.)
t<-lm(log10(Body.mass..g.)~log10(Calculated.MRs..mL.O2...1.h...1.g.), data=dat.lm%>%filter(Age=="Extant", thermy_3_cat=="known endotherm"))
confint(t,'log10(Calculated.MRs..mL.O2...1.h...1.g.)',level=0.95)
t2<- lm(log10(Body.mass..g.)~log10(Calculated.MRs..mL.O2...1.h...1.g.), data=dat.lm%>%filter(Age=="Extant", thermy_3_cat=="known other"))
confint(t2,'log10(Calculated.MRs..mL.O2...1.h...1.g.)',level=0.95)
```


The extant calibration is pulling a lot of statistical weight in the Weimann _et al._ analyses. We know that at least the _Dendrocygna_ point is incorrect, but beyond that if we regress Log_10 Mass specific MR against Log_10(body mass (g)) we do not obtain the expected negative slope of (-1/4)as predicted by allometric scaling. Instead we get essentially flat (even slightly positive), non-significant relationships ( _P_ = 0.583).

# Discriminant Analysis

The authors use a discriminant analysis as a validation of their question but bury it in the extended data figures and do not label points. It does not appear to end up paramterizing any of the downstream classification.

```{r, echo=F, eval=F}
set.seed(123)
training.samples <- disc.df$Taxon.Name %>%
  createDataPartition(p = 0.8, list = FALSE)
train.data <- disc.df[training.samples, ]
test.data <- disc.df[-training.samples, ]


```


# Bayesian Predictive Models

We will run logistic Bayesian models with probability of endothermy as the response using only extant data or presumed thermy data from fossil record (acting as the training set). We will then test classification success on the fossil data and simulated data parameterized on fossils, on known enodtherms, and known ectotherms separately.

## Create response variable

We will code a dummy variable with a 1 for endotherm and a 0 for non-endotherm, standardize predictors, etc...

```{r}

dat.brms <- full.analyses.df%>%
  mutate(endo=if_else(classification %in% c("endo"), 1, 0),
         log10_adj_corr_MR.z = standardize(log10(adj_corr_MR)),
         log10_mass.z = standardize(Log.10..Body.Mass..g.),
         log10_MR_corr_no_mass_z = standardize(Log.10.MR.corr))
```

### Run a intercept only model with mass-specific MR
  
```{r, echo=F}
#use this to get idea of priors then set your own!!
# priors <-get_prior(endo ~ 1, data = dat.brms%>%filter(Age=="Extant"), family = bernoulli())
# 
# int.only <- brm(
#   formula = brms::bf(endo ~ 1),
#   data = dat.brms%>%filter(Age=="Extant"),
#   family = bernoulli(),
#   cores = 4,
#   chains = 4,
#   thin = 10, #chop out transitions?
#   warmup = 5000, #half of iterations
#   iter = 10000,
#   #prior = c(
#   #     prior(normal(0, 10), "Intercept"),
#   #     prior(cauchy(0, 2.5), "sigma")),
#   prior = priors,
#   save_pars = save_pars(all = TRUE), #need this for loo comparison
#   control = list(adapt_delta = 0.97, max_treedepth = 18), #adapt_delta the target average proposal acceptance probability during Stan's adaptation period
#   set.seed(2020)
# )
# 
# save(int.only, file=paste(getwd(),"/brms_models/", "int_only.RData", sep="")) # save model

load(file=paste(getwd(),"/brms_models/", "int_only.RData", sep="")) # If loading from pre-saved file and not re-running

#pp_check(int.only, ndraws = 100) 
#pp_check(int.only, type = "stat", stat = 'median', ndraws = 2000)
#pp_check(int.only, type = "stat", stat = 'mean', ndraws = 2000)

# trace and density plots
#plot(int.only)

```

### Run an additive model with predictor: log10_adj_corr_MR.z (log 10(standardized adjusted MR from our re-calibrations)
  
```{r, echo=F}
#use this to get idea of priors then set your own!!
priors <-get_prior(endo ~ log10_adj_corr_MR.z, data = dat.brms%>%filter(Age=="Extant"), family = bernoulli())

MR.only <- brm(
  formula = brms::bf(endo ~ log10_adj_corr_MR.z),
  data = dat.brms%>%filter(Age=="Extant"),
  family = bernoulli(),
  cores = 4,
  chains = 4,
  thin = 10, #chop out transitions?
  warmup = 5000, #half of iterations
  iter = 10000,
  prior = c(
       prior(student_t(3, 0, 2.5), "Intercept"),
       prior(normal(0, 10), "b")),
  #prior = priors,
  save_pars = save_pars(all = TRUE), #need this for loo comparison
  control = list(adapt_delta = 0.97, max_treedepth = 18), #adapt_delta the target average proposal acceptance probability during Stan's adaptation period
  set.seed(2020)
)

# save(MR.only, file=paste(getwd(),"/brms_models/", "MR_only.RData", sep="")) # save model

load(paste(getwd(),"/brms_models/", "MR_only.RData", sep="")) # If loading from pre-saved file and not re-running

#pp_check(MR.only, ndraws = 100) 
#pp_check(MR.only, type = "stat", stat = 'median', ndraws = 2000)
#pp_check(MR.only, type = "stat", stat = 'mean', ndraws = 2000)

# trace and density plots
#plot(MR.only)

me <- conditional_effects(MR.only, "log10_adj_corr_MR.z")
p <-plot(me, plot = FALSE)[[1]] +
  scale_color_grey() +
  scale_fill_grey()+
  theme(axis.text.y   = element_text(size=14),
        axis.text.x   = element_text(size=14),
        axis.title.y  = element_text(size=14),
        axis.title.x  = element_text(size=14),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=0.5))+labs(y="Probabilty of endothermy", x= "MC Vivo")
p
```

### Run an additive model with predictors: log10_adj_corr_MR.z (log 10(standardized adjusted MR from our re-calibrations); Log.10..Body.Mass..g.z (what a nice name, standardized log10 body mass in grams)
  
```{r, echo=F}
#use this to get idea of priors then set your own!!
priors <-get_prior(endo ~ log10_adj_corr_MR.z + log10_mass.z, data = dat.brms%>%filter(Age=="Extant"), family = bernoulli(link = "logit"))

MR.mass <- brm(
  formula = brms::bf(endo ~ log10_adj_corr_MR.z + log10_mass.z ),
  data = dat.brms%>%filter(Age=="Extant"),
  family = bernoulli(link = "logit"),
  cores = 4,
  chains = 4,
  thin = 10, #chop out transitions?
  warmup = 5000, #half of iterations
  iter = 10000,
  prior = c(
      prior(student_t(3, 0, 2.5), "Intercept"),
      prior(normal(0, 5), "b")),
  #prior = priors,
  save_pars = save_pars(all = TRUE), #need this for loo comparison
  control = list(adapt_delta = 0.97, max_treedepth = 18), #adapt_delta the target average proposal acceptance probability during Stan's adaptation period
  set.seed(2020)
)

save(MR.mass, file=paste(getwd(),"/brms_models/", "MR_mass.RData", sep="")) # save model

load(paste(getwd(),"/brms_models/", "MR_mass.RData", sep="")) # If loading from pre-saved file and not re-running

#pp_check(MR.mass, ndraws = 100) 
#pp_check(MR.mass, type = "stat", stat = 'median', ndraws = 2000)
#pp_check(MR.mass, type = "stat", stat = 'mean', ndraws = 2000)

# trace and density plots
#plot(MR.mass)


me <- conditional_effects(MR.mass, "log10_adj_corr_MR.z")
p <-plot(me, plot = FALSE)[[1]] +
  scale_color_grey() +
  scale_fill_grey()+
  theme(axis.text.y   = element_text(size=14),
        axis.text.x   = element_text(size=14),
        axis.title.y  = element_text(size=14),
        axis.title.x  = element_text(size=14),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=0.5))+labs(y="Probabilty of endothermy", x= "MC Vivo")
p

#This is just cleaner theme
#plot_cap(MR.mass, condition = "log10_adj_corr_MR.z")

```

## Model selection
### WAIC
```{r, echo=F, warning=F, message =F, eval=F}
int.waic <- waic(int.only)
MR.waic <- waic(MR.only)
MR.mass.waic <- waic(MR.mass)

model.waics <- cbind(int.waic, MR.waic, MR.mass.waic); model.waics
#as usual WAIC can't be used...try loo instead

```

### LOO

```{r, echo=F, warning=F, message =F, eval=F}
LOO(int.only, MR.only, MR.mass, reloo=TRUE, moment_match = TRUE) 

#LOO likes MR.only model best but MR.mass is very close. we will go with that

```

## Check predictive power of best model 
### Predict from posterior
```{r}
pred <- marginaleffects::predictions(MR.only,
                    newdata = datagrid(log10_adj_corr_MR.z = dat.brms%>%filter(Age=="Extant")%>% pull(log10_adj_corr_MR.z)))


pred <- posteriordraws(pred)

mod.tax <- dat.brms%>%filter(Age=="Extant")%>% pull(Taxon) %>% as.character()

pred$taxon <-rep(mod.tax, times=200)

pred <-left_join(pred, full.analyses.df%>%filter(Age=="Extant")%>%dplyr::select(Taxon, termy_3_cat)%>%dplyr::rename(taxon=Taxon))

ext.pr <- pred%>%
  group_by(taxon)%>%
  summarize(log10_adj_corr_MR.z = median(log10_adj_corr_MR.z),
            draw= median(draw))

ggplot(pred, aes(x = log10_adj_corr_MR.z, y = draw))+
    stat_lineribbon(color="transparent") +
  stat_halfeye(aes(color=termy_3_cat), point_interval = "median_qi", .width = c(0.5, 0.8,0.95)) +
  #geom_point(data=oth.pr)+
   # geom_pointrange(data=oth.pr, aes(ymin = lwr, ymax = upper))+
    scale_fill_brewer(palette = "Greys") +
    labs(x = "MC Vivo",
         y = "Probability of endothermy",
         fill = "")+
  scale_color_manual(values=c("blue", "red"))+
  geom_text(data=ext.pr, aes(label=taxon), size=2,color="black",
    nudge_x = 0.1, nudge_y = -0.0, 
    check_overlap = F
  )+
  theme(legend.position = c(0.2, 0.75))

```

### Check predictive power of model using the fossil taxa of other thermy
```{r, echo=F}
pred.foss.oth <- predictions(MR.only,
                    newdata = datagrid(log10_adj_corr_MR.z = dat.brms%>%filter(Age=="Fossil",classification=="oth")%>% pull(log10_adj_corr_MR.z)))

pred.foss.oth <- posteriordraws(pred.foss.oth)

oth.tax<-dat.brms%>%filter(Age=="Fossil",classification=="oth")%>% dplyr::select(Taxon,log10_adj_corr_MR.z)%>%pull(Taxon)

pred.foss.oth$taxon <-rep(oth.tax, times=2000)

pred.foss.oth<-left_join(pred.foss.oth, full.analyses.df%>%filter(Age=="Fossil", classification=="oth")%>%dplyr::select(Taxon, termy_3_cat)%>%dplyr::rename(taxon=Taxon))

oth.pr <- pred.foss.oth%>%
  group_by(taxon)%>%
  summarize(log10_adj_corr_MR.z = median(log10_adj_corr_MR.z),
            draw= median(draw),
         lwr = quantile(conf.low, probs=0.25),
         upper = quantile(conf.high, probs=0.75))


ggplot(pred, aes(x = log10_adj_corr_MR.z, y = draw)) +
    stat_lineribbon(color="transparent") +
  stat_halfeye(data=pred.foss.oth,color="grey85", point_interval = "median_qi", .width = c(0.5, 0.8,0.95)) +
  #geom_point(data=oth.pr)+
   #geom_pointrange(data=oth.pr, aes(ymin = lwr, ymax = upper))+
    scale_fill_brewer(palette = "Greys") +
    labs(x = "MC Vivo",
         y = "Probability of endothermy",
         fill = "")+
  #scale_color_manual(values=c("blue", "red"))+
  geom_text(data=oth.pr, aes(label=taxon), size=2,color="black",
    nudge_x = 0.1, nudge_y = -0.0, 
    check_overlap = F
  )
```


```{r, echo=F, warning=F, message=F}

pred.foss.endo <- predictions(MR.only, 
                    newdata = datagrid(log10_adj_corr_MR.z = dat.brms%>%filter(Age=="Fossil",classification=="endo") %>%pull(log10_adj_corr_MR.z)))

pred.foss.endo <- posteriordraws(pred.foss.endo)

endo.tax<-dat.brms%>%filter(Age=="Fossil",classification=="endo")%>% dplyr::select(Taxon,log10_adj_corr_MR.z)%>%pull(Taxon)

pred.foss.endo$taxon <-rep(endo.tax, times=2000)

endo.pr <- pred.foss.endo%>%
  group_by(taxon)%>%
  summarize(log10_adj_corr_MR.z = median(log10_adj_corr_MR.z),
            draw= median(draw),
         lwr = quantile(conf.low, probs=0.25),
         upper = quantile(conf.high, probs=0.75))


ggplot(pred, aes(x = log10_adj_corr_MR.z, y = draw)) +
    stat_lineribbon(color="transparent") +
  stat_halfeye(data=pred.foss.oth,color="grey85", point_interval = "median_qi", .width = c(0.5, 0.8,0.95)) +
  stat_halfeye(data=pred.foss.endo,color="red", point_interval = "median_qi", .width = c(0.5, 0.8,0.95)) +
  #geom_point(data=oth.pr)+
   #geom_pointrange(data=oth.pr, aes(ymin = lwr, ymax = upper), color="grey")+
  #geom_pointrange(data=endo.pr, aes(ymin = lwr, ymax = upper), color="red")+
    scale_fill_brewer(palette = "Greys") +
    labs(x = "MC Vivo",
         y = "Probability of endothermy",
         fill = "")+
  geom_text(data=endo.pr, aes(label=taxon), size=2, color="black",
    nudge_x = 0, nudge_y = 0,
    check_overlap = F
  )+
  geom_text(data=oth.pr, aes(label=taxon), size=2, color="black",
    nudge_x = 0, nudge_y = 0,
    check_overlap = F
  )+
  theme(legend.position = c(0.8,0.3))


  
```

### Confusion Matrix
```{r, echo=F, message =F, warning = F, eval=f}
#Can't really do confusion matrix unless we assign ectotherm to unknown fossils...
confusionMatrix(dat.brms%>%filter(Age=="Extant"), pred.foss.endo)
```

### Run a intercept only model with MR mass divided out (as in Weimann analysis figure 1D) 

Psych! don't need to run this already did
  
  
### Run an additive model with predictor: Log.10.MR.corr.z (standardized log10(adjusted MR) from our re-calibrations with mass divided out as in Weimann figure 1D.)
  
```{r, echo=F}
#use this to get idea of priors then set your own!!
# priors <-get_prior(endo ~ log10_MR_corr_no_mass_z, data = dat.brms%>%filter(Age=="Extant"), family = bernoulli())
# 
# MR.no.mass.only <- brm(
#   formula = brms::bf(endo ~ log10_MR_corr_no_mass_z),
#   data = dat.brms%>%filter(Age=="Extant"),
#   family = bernoulli(),
#   cores = 4,
#   chains = 4,
#   thin = 10, #chop out transitions?
#   warmup = 5000, #half of iterations
#   iter = 10000,
#   #prior = c(
#   #     prior(normal(0, 10), "Intercept"),
#   #     prior(cauchy(0, 2.5), "sigma")),
#   prior = priors,
#   save_pars = save_pars(all = TRUE), #need this for loo comparison
#   control = list(adapt_delta = 0.97, max_treedepth = 18), #adapt_delta the target average proposal acceptance probability during Stan's adaptation period
#   set.seed(2020)
# )
# 
# save(MR.no.mass.only, file=paste(getwd(),"/brms_models/", "MR_no_mass_only.RData", sep="")) # save model

load(paste(getwd(),"/brms_models/", "MR_no_mass_only.RData", sep="")) # If loading from pre-saved file and not re-running

#pp_check(MR.only, ndraws = 100) 
#pp_check(MR.only, type = "stat", stat = 'median', ndraws = 2000)
#pp_check(MR.only, type = "stat", stat = 'mean', ndraws = 2000)

# trace and density plots
#plot(MR.only)

```

### Run an additive model with predictors: log10_adj_corr_MR.z (standardized log10(adjusted MR no mass) from our re-calibrations as in Weimann figure 1D); Log.10..Body.Mass..g.z (what a nice name, standardized log10 body mass in grams)
  
```{r, echo=F}

#use this to get idea of priors then set your own!!
# priors <-get_prior(endo ~ log10_MR_corr_no_mass_z + log10_mass.z, data = dat.brms%>%filter(Age=="Extant"), family = bernoulli(link = "logit"))
# 
# MR.no.mass.mass <- brm(
#   formula = brms::bf(endo ~ log10_MR_corr_no_mass_z + log10_mass.z ),
#   data = dat.brms%>%filter(Age=="Extant"),
#   family = bernoulli(link = "logit"),
#   cores = 4,
#   chains = 4,
#   thin = 10, #chop out transitions?
#   warmup = 5000, #half of iterations
#   iter = 10000,
#   #prior = c(
#   #     prior(student_t(3, 0, 2.5), "Intercept"),
#   #     prior(normal(0, 1.5), "b")),
#   prior = priors,
#   save_pars = save_pars(all = TRUE), #need this for loo comparison
#   control = list(adapt_delta = 0.97, max_treedepth = 18), #adapt_delta the target average proposal acceptance probability during Stan's adaptation period
#   set.seed(2020)
# )
# 
# save(MR.no.mass.mass, file=paste(getwd(),"/brms_models/", "MR_no_mass-mass.RData", sep="")) # save model

load(paste(getwd(),"/brms_models/", "MR_no_mass-mass", sep="")) # If loading from pre-saved file and not re-running

#pp_check(MR.no.mass.mass, ndraws = 100) 
#pp_check(MR.no.mass.mass, type = "stat", stat = 'median', ndraws = 2000)
#pp_check(MR.no.mass.mass, type = "stat", stat = 'mean', ndraws = 2000)

# trace and density plots
#plot(MR.no.mass.mass)


me <- conditional_effects(MR.no.mass.mass, "log10_MR_corr_no_mass_z")
p <-plot(me, plot = FALSE)[[1]] +
  scale_color_grey() +
  scale_fill_grey()+
  theme(axis.text.y   = element_text(size=14),
        axis.text.x   = element_text(size=14),
        axis.title.y  = element_text(size=14),
        axis.title.x  = element_text(size=14),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=0.5))+labs(y="Probabilty of endothermy", x= "MC Vivo")
p

#This is just cleaner theme
#plot_cap(MR.mass, condition = "log10_MR_corr_no_mass_z")

```

## Model selection
### WAIC
```{r, echo=F, warning=F, message =F, eval=F}
int.waic <- waic(int.only)
MR.waic <- waic(MR.no.mass.only)
MR.mass.waic <- waic(MR.no.mass.mass)

model.waics <- cbind(int.waic, MR.waic, MR.mass.waic); model.waics
#as usual WAIC can't be used...try loo instead

```

### LOO

```{r, echo=F, warning=F, message =F, eval=F}
LOO(int.only, MR.no.mass.only, MR.no.mass.mass, reloo=TRUE, moment_match = TRUE) 

#MR-no mass by mass best

```

## Check predictive power of best model 
### Predict from posterior
```{r}
pred <- predictions(MR.no.mass.mass,
                    newdata = datagrid(log10_MR_corr_no_mass_z = dat.brms%>%filter(Age=="Extant")%>% pull(log10_MR_corr_no_mass_z),
                                       log10_mass.z = dat.brms%>%filter(Age=="Extant")%>%pull(log10_mass.z)))


pred <- posteriordraws(pred)


pred$taxon <-rep(mod.tax, each=20)

pred <-left_join(pred, full.analyses.df%>%filter(Age=="Extant")%>%dplyr::select(Taxon, termy_3_cat)%>%dplyr::rename(taxon=Taxon))

ggplot(pred, aes(x = log10_MR_corr_no_mass_z, y = predicted)) +
    stat_lineribbon(color="transparent") +
  stat_halfeye(aes(color=termy_3_cat), point_interval = "median_qi", p_limits = c(0.05, 0.95), alpha=0.3) +
  #geom_point(data=oth.pr)+
   # geom_pointrange(data=oth.pr, aes(ymin = lwr, ymax = upper))+
    scale_fill_brewer(palette = "Greys") +
    labs(x = "MC Vivo",
         y = "Probability of endothermy",
         fill = "")+
  scale_color_manual(values=c("blue", "red"))+
  geom_text(data=pred%>% group_by(taxon)%>%summarise(predicted=median(predicted, na.rm=T),log10_MR_corr_no_mass_z = median(log10_MR_corr_no_mass_z)), aes(label=taxon), size=2,color="grey35",
    nudge_x = 0.8, nudge_y = 0,
    check_overlap = F
  )+
  theme(legend.position = c(0.7, 0.2))

```

### Check predictive power of model using the fossil taxa of other thermy
```{r, echo=F}
pred.foss.oth <- predictions(MR.mass,
                    newdata = datagrid(log10_MR_corr_no_mass_z = dat.brms%>%filter(Age=="Fossil",classification=="oth")%>% pull(log10_MR_corr_no_mass_z),
                                       log10_mass.z = dat.brms%>%filter(Age=="Fossil", classification=="oth")%>%pull(log10_mass.z)))

pred.foss.oth <- posteriordraws(pred.foss.oth)

oth.tax<-dat.brms%>%filter(Age=="Fossil",classification=="oth")%>% dplyr::select(Taxon,log10_MR_corr_no_mass_z, log10_mass.z)%>%pull(Taxon)

pred.foss.oth$taxon <-rep(oth.tax, each=15)

pred.foss.oth<-left_join(pred.foss.oth, full.analyses.df%>%filter(Age=="Fossil", classification=="oth")%>%dplyr::select(Taxon, termy_3_cat)%>%dplyr::rename(taxon=Taxon))

oth.pr <- pred.foss.oth%>%
  group_by(taxon)%>%
  summarize(log10_MR_corr_no_mass_z = median(log10_MR_corr_no_mass_z),
            draw= median(draw),
         lwr = quantile(conf.low, probs=0.25),
         upper = quantile(conf.high, probs=0.75))


ggplot(pred.foss.oth, aes(x = log10_MR_corr_no_mass_z, y = draw)) +
    stat_lineribbon(color="transparent") +
  stat_halfeye(color="grey85", point_interval = "median_qi", p_limits = c(0.05, 0.95)) +
  #geom_point(data=oth.pr)+
   # geom_pointrange(data=oth.pr, aes(ymin = lwr, ymax = upper))+
    scale_fill_brewer(palette = "Greys") +
    labs(x = "MC Vivo",
         y = "Probability of endothermy",
         fill = "")+
  #scale_color_manual(values=c("blue", "red"))+
  geom_text(data=oth.pr, aes(label=taxon), size=2,color="black",
    nudge_x = 0.1, nudge_y = -0.0, 
    check_overlap = F
  )
```


```{r, echo=F, warning=F, message=F}

pred.foss.endo <- predictions(MR.mass, 
                    newdata = datagrid(log10_MR_corr_no_mass_z = dat.brms%>%filter(Age=="Fossil",classification=="endo") %>%pull(log10_MR_corr_no_mass_z),
                                       log10_mass.z = dat.brms%>%filter(Age=="Fossil", classification=="endo")%>%pull(log10_mass.z)))

pred.foss.endo <- posteriordraws(pred.foss.endo)

endo.tax<-dat.brms%>%filter(Age=="Fossil",classification=="endo")%>% dplyr::select(Taxon,log10_MR_corr_no_mass_z, log10_mass.z)%>%pull(Taxon)

pred.foss.endo$taxon <-rep(endo.tax, each=6)

endo.pr <- pred.foss.endo%>% #This just creates the appropraite number of labels and puts them in the right spot
  group_by(taxon)%>%
  summarize(log10_MR_corr_no_mass_z = median(log10_MR_corr_no_mass_z),
            draw= median(draw),
         lwr = quantile(conf.low, probs=0.25),
         upper = quantile(conf.high, probs=0.75))


ggplot(pred.foss.endo, aes(x = log10_MR_corr_no_mass_z, y = draw)) +
    stat_lineribbon(color="transparent") +
  stat_halfeye(color="red", point_interval = "median_qi", p_limits = c(0.05, 0.95), alpha=0.3) +
  #geom_point(data=oth.pr)+
   # geom_pointrange(data=oth.pr, aes(ymin = lwr, ymax = upper))+
    scale_fill_brewer(palette = "Greys") +
    labs(x = "MC Vivo",
         y = "Probability of endothermy",
         fill = "")+
  geom_text(data=endo.pr, aes(label=taxon), size=2, color="grey45",
    nudge_x = 0.4, nudge_y = -0.01,
    check_overlap = F
  )


  
```